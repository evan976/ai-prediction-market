/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Account,
  type Address,
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  type Codec,
  combineCodec,
  type Decoder,
  decodeAccount,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
  transformEncoder,
} from '@solana/kit'

export const MARKET_DISCRIMINATOR = new Uint8Array([
  219, 190, 213, 55, 0, 227, 198, 154,
])

export function getMarketDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(MARKET_DISCRIMINATOR)
}

export type Market = {
  discriminator: ReadonlyUint8Array
  question: string
  endTime: bigint
  creator: Address
  yesPool: bigint
  noPool: bigint
  isResolved: boolean
  outcome: number
}

export type MarketArgs = {
  question: string
  endTime: number | bigint
  creator: Address
  yesPool: number | bigint
  noPool: number | bigint
  isResolved: boolean
  outcome: number
}

/** Gets the encoder for {@link MarketArgs} account data. */
export function getMarketEncoder(): Encoder<MarketArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['question', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ['endTime', getI64Encoder()],
      ['creator', getAddressEncoder()],
      ['yesPool', getU64Encoder()],
      ['noPool', getU64Encoder()],
      ['isResolved', getBooleanEncoder()],
      ['outcome', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: MARKET_DISCRIMINATOR }),
  )
}

/** Gets the decoder for {@link Market} account data. */
export function getMarketDecoder(): Decoder<Market> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['question', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ['endTime', getI64Decoder()],
    ['creator', getAddressDecoder()],
    ['yesPool', getU64Decoder()],
    ['noPool', getU64Decoder()],
    ['isResolved', getBooleanDecoder()],
    ['outcome', getU8Decoder()],
  ])
}

/** Gets the codec for {@link Market} account data. */
export function getMarketCodec(): Codec<MarketArgs, Market> {
  return combineCodec(getMarketEncoder(), getMarketDecoder())
}

export function decodeMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<Market, TAddress>
export function decodeMarket<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Market, TAddress>
export function decodeMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Market, TAddress> | MaybeAccount<Market, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getMarketDecoder(),
  )
}

export async function fetchMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<Market, TAddress>> {
  const maybeAccount = await fetchMaybeMarket(rpc, address, config)
  assertAccountExists(maybeAccount)
  return maybeAccount
}

export async function fetchMaybeMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<Market, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config)
  return decodeMarket(maybeAccount)
}

export async function fetchAllMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<Market>[]> {
  const maybeAccounts = await fetchAllMaybeMarket(rpc, addresses, config)
  assertAccountsExist(maybeAccounts)
  return maybeAccounts
}

export async function fetchAllMaybeMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<Market>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
  return maybeAccounts.map((maybeAccount) => decodeMarket(maybeAccount))
}
