/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Account,
  type Address,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
  transformEncoder,
} from '@solana/kit'

export const BET_RECORD_DISCRIMINATOR = new Uint8Array([
  144, 217, 102, 109, 200, 164, 66, 178,
])

export function getBetRecordDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(BET_RECORD_DISCRIMINATOR)
}

export type BetRecord = {
  discriminator: ReadonlyUint8Array
  market: Address
  bettor: Address
  yesAmount: bigint
  noAmount: bigint
  claimed: boolean
}

export type BetRecordArgs = {
  market: Address
  bettor: Address
  yesAmount: number | bigint
  noAmount: number | bigint
  claimed: boolean
}

/** Gets the encoder for {@link BetRecordArgs} account data. */
export function getBetRecordEncoder(): FixedSizeEncoder<BetRecordArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['market', getAddressEncoder()],
      ['bettor', getAddressEncoder()],
      ['yesAmount', getU64Encoder()],
      ['noAmount', getU64Encoder()],
      ['claimed', getBooleanEncoder()],
    ]),
    (value) => ({ ...value, discriminator: BET_RECORD_DISCRIMINATOR }),
  )
}

/** Gets the decoder for {@link BetRecord} account data. */
export function getBetRecordDecoder(): FixedSizeDecoder<BetRecord> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['market', getAddressDecoder()],
    ['bettor', getAddressDecoder()],
    ['yesAmount', getU64Decoder()],
    ['noAmount', getU64Decoder()],
    ['claimed', getBooleanDecoder()],
  ])
}

/** Gets the codec for {@link BetRecord} account data. */
export function getBetRecordCodec(): FixedSizeCodec<BetRecordArgs, BetRecord> {
  return combineCodec(getBetRecordEncoder(), getBetRecordDecoder())
}

export function decodeBetRecord<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<BetRecord, TAddress>
export function decodeBetRecord<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<BetRecord, TAddress>
export function decodeBetRecord<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<BetRecord, TAddress> | MaybeAccount<BetRecord, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getBetRecordDecoder(),
  )
}

export async function fetchBetRecord<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<BetRecord, TAddress>> {
  const maybeAccount = await fetchMaybeBetRecord(rpc, address, config)
  assertAccountExists(maybeAccount)
  return maybeAccount
}

export async function fetchMaybeBetRecord<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<BetRecord, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config)
  return decodeBetRecord(maybeAccount)
}

export async function fetchAllBetRecord(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<BetRecord>[]> {
  const maybeAccounts = await fetchAllMaybeBetRecord(rpc, addresses, config)
  assertAccountsExist(maybeAccounts)
  return maybeAccounts
}

export async function fetchAllMaybeBetRecord(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<BetRecord>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
  return maybeAccounts.map((maybeAccount) => decodeBetRecord(maybeAccount))
}

export function getBetRecordSize(): number {
  return 89
}
